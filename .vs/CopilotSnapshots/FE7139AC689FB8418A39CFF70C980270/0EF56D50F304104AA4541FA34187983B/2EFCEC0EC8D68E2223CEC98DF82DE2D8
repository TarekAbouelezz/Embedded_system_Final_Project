/**
 * @file AGV.cpp
 * @brief AGV implementation with state machine
 */

/******************************Project Headers*****************************************/
#include "AGV.h"
#include "AssemblyStation.h"
#include <iostream>
#include <chrono>
#include <thread>
/*************************************************************************************/

/****************************AGV Methods**********************************************/
/**
 * @brief Constructor for AGV
 * @param id Unique identifier for the AGV
 */
AGV::AGV(int id) 
    : agv_id(id), 
      state(AGVState::IDLE), 
      running(false),
      travel_time_warehouse_minutes(2),
      travel_time_station_minutes(3),
      picking_time_minutes(1),
      dropping_time_minutes(1),
      total_operations(0),
      busy_time_minutes(0) {
}

/**
 * @brief Destructor for AGV
 */
AGV::~AGV() {
    stop();
    if (agv_thread.joinable()) {
        agv_thread.join();
    }
}


/**
 * @brief Start the AGV thread
 */
void AGV::start() {
    running = true;
    agv_thread = std::thread(&AGV::run, this);  //Start AGV thread
}

/**
 * @brief Stop the AGV thread
 */
void AGV::stop() {
    running = false;
    task_cv.notify_all(); //Signal to stop
}


/**
 * @brief Main AGV state machine loop
 */
void AGV::run() {
    while (running) {
        std::unique_lock<std::mutex> lock(state_mutex);   //mustex wait for task
        
        // Wait for task assignment
        task_cv.wait(lock, [this] {
            return !running || !current_task.component_id.empty(); 
        });
        
        if (!running) break;
        
        if (current_task.component_id.empty()) {
            continue;
        }
        
        // Execute task
        // Transition to TO_WAREHOUSE
        transition_to(AGVState::TO_WAREHOUSE);
        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(
            travel_time_warehouse_minutes * 100)); // Scaled for simulation
        
        // Picking
        lock.lock();
        transition_to(AGVState::PICKING);
        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(
            picking_time_minutes * 100));
        
        // Travel to station
        lock.lock();
        transition_to(AGVState::TO_STATION);
        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(
            travel_time_station_minutes * 100));
        
        // Dropping
        lock.lock();
        transition_to(AGVState::DROPPING);
        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(
            dropping_time_minutes * 100));
        
        // Complete task
        lock.lock();
        current_task.is_complete = true;
        busy_time_minutes.fetch_add(travel_time_warehouse_minutes + 
                                    picking_time_minutes + 
                                    travel_time_station_minutes + 
                                    dropping_time_minutes, std::memory_order_relaxed);
        total_operations.fetch_add(1, std::memory_order_relaxed);
        
        // Notify station of delivery (1 unit)
        if (current_task.notify_station && current_task.destination == std::string("ASSEMBLY_STATION")) {
            // Call without holding the mutex to avoid potential deadlocks
            AssemblyStation* station_to_notify = current_task.notify_station;
            std::string comp = current_task.component_id;
            lock.unlock();
            station_to_notify->notify_component_delivered(comp, 1);
            lock.lock();
        }
        
        // Reset task
        current_task = AGVTask();
        transition_to(AGVState::IDLE);
        lock.unlock();
    }
}


/**
 * @brief Transition AGV to a new state
 * @param new_state The new state to transition to
 */
void AGV::transition_to(AGVState new_state) {
    state = new_state;
}



/**
 * @brief Assign a new task to the AGV
 * @param component_id ID of the component to pick
 * @param quantity Quantity to pick (per task, should be 1)
 * @param destination Destination ("ASSEMBLY_STATION" or "WAREHOUSE")
 * @param notify_station Optional station to notify upon delivery
 */
void AGV::assign_task(const std::string& component_id, int quantity,
                      const std::string& destination,
                      AssemblyStation* notify_station) {
    std::lock_guard<std::mutex> lock(state_mutex);  //mustex wait assign task
    
    if (state == AGVState::IDLE && current_task.component_id.empty()) {
        current_task.component_id = component_id;
        current_task.quantity = quantity;
        current_task.destination = destination;
        current_task.is_complete = false;
        current_task.notify_station = notify_station;
        task_cv.notify_one();   // Signal new task
    }
}


/**
 * @brief Check if AGV is idle
 * @return true if AGV is idle, false otherwise
 */
bool AGV::is_idle() const {
    std::lock_guard<std::mutex> lock(state_mutex);  //mustex wait check idle
    return state == AGVState::IDLE && current_task.component_id.empty();
}


/**
 * @brief Get the current state of the AGV
 * @return Current AGV state
 */
AGVState AGV::get_state() const {
    std::lock_guard<std::mutex> lock(state_mutex);  //mustex wait get state
    return state;
}


/**
 * @brief Get the current task assigned to the AGV
 * @return Current AGV task
 */
AGVTask AGV::get_current_task() const {
    std::lock_guard<std::mutex> lock(state_mutex);  //mustex wait get task
    return current_task; 
}

/*************************************************************************************/
